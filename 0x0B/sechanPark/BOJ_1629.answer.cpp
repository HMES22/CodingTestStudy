/*
* 출처 : https://www.acmicpc.net/problem/1629

* 번호(파일이름) :  BOJ_1629.answer.cpp

* 문제/난이도/시간(커밋 시 첨부) : [BOJ] 곱셈 / 실버1 / 60분

* 설명 :
	- 숫자, 승수, 나눗셈할꺼 주어짐
	- 숫자가 개 크니깐 나눠서 나머지나 내놓아라 그런 

* 풀이 :
	1) 이거는 분할해서 풀어야하는 문제임 
	2) 예를 들어서 2의4승 이면 2^2 X 2^2 이랑 같은거 
	3) 만약 2의 5승처럼 홀수 승이면 2^2 X 2^2 X 2 랑 같은거 
	4) 나머지 연산은 (A*B)% 이면 (A% * B%)% 랑 같은거 (1의 자리 구하기랑 비슷하게 생각하면되는데, 3 * 4* 5의 일의 자리 구할때 각 자리의 1의 자리 곱하기 전체 1의자리 ㅇㅇ 그거랑 비슷)
* 기타 :
	- 솔찍히 잘 이해 안됨 
	- b == 1 에서 a만 반환 해도 되는데 %m 하는 이유는 a가 m보다 클 수 있어서
	- 여기서 이제 내가 햇갈렸던게 나오는데
	- 홀수 지수 리턴 상황에서 *a 하고 다시 %m 하는 이유도 위와 마찬가지로 m보다 클 수 있어서임 ㅇㅇ 
	- why? 나머지 연산은 몫이 0일떄까지 해야하는거니깐 이게 큰게 말이되냐 이말이지..
*/
#include <iostream>
using namespace std; 

using ll = long long;

//반띵 방법으로 분할정복, 하나하나 쪼개면 재귀 많이 돌았을꺼임
ll POW(ll a, ll b, ll m) {
	if (b == 1) return a % m; // 이거 이해 안되면 바킹독 블로그 댓글 참고, 나랑 똑같은 놈 있음
	if (b == 0) return 1; 

	ll val = POW(a, b / 2, m);
	val = (val * val) % m; 

	if (b % 2 == 0) return val; 
	return (val * a )% m;         
}

int main() {
	ll a, b, c; 

	cin >> a >> b >> c; 
	cout << POW(a, b, c); 
}